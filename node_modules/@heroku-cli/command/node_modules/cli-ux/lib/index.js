"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Errors = require("@oclif/errors");
const util = require("util");
const base_1 = require("./action/base");
exports.ActionBase = base_1.ActionBase;
const config_1 = require("./config");
exports.config = config_1.config;
exports.Config = config_1.Config;
const deps_1 = require("./deps");
const exit_1 = require("./exit");
exports.ExitError = exit_1.ExitError;
const Table = require("./styled/table");
exports.Table = Table;
exports.cli = {
    config: config_1.config,
    warn: Errors.warn,
    error: Errors.error,
    exit: Errors.exit,
    get prompt() { return deps_1.default.prompt.prompt; },
    get confirm() { return deps_1.default.prompt.confirm; },
    get action() { return config_1.config.action; },
    styledObject(obj, keys) { exports.cli.info(deps_1.default.styledObject(obj, keys)); },
    get styledHeader() { return deps_1.default.styledHeader; },
    get styledJSON() { return deps_1.default.styledJSON; },
    get table() { return deps_1.default.table; },
    async done() {
        config_1.config.action.stop();
        // await flushStdout()
    },
    trace(format, ...args) {
        if (this.config.outputLevel === 'trace') {
            process.stdout.write(util.format(format, ...args) + '\n');
        }
    },
    debug(format, ...args) {
        if (['trace', 'debug'].includes(this.config.outputLevel)) {
            process.stdout.write(util.format(format, ...args) + '\n');
        }
    },
    info(format, ...args) {
        process.stdout.write(util.format(format, ...args) + '\n');
    },
    log(format, ...args) {
        this.info(format, ...args);
    },
};
exports.default = exports.cli;
process.once('exit', async () => {
    try {
        await exports.cli.done();
    }
    catch (err) {
        // tslint:disable no-console
        console.error(err);
        process.exitCode = 1;
    }
});
// async function flushStdout() {
//   function timeout(p: Promise<any>, ms: number) {
//     function wait(ms: number, unref: boolean = false) {
//       return new Promise(resolve => {
//         let t: any = setTimeout(resolve, ms)
//         if (unref) t.unref()
//       })
//     }
//     return Promise.race([p, wait(ms, true).then(() => cli.warn('timed out'))])
//   }
//   async function flush() {
//     let p = new Promise(resolve => process.stdout.once('drain', resolve))
//     process.stdout.write('')
//     return p
//   }
//   await timeout(flush(), 10000)
// }
